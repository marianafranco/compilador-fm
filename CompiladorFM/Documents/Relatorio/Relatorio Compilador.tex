% !TEX encoding = IsoLatin
\documentclass[12pt,a4paper,titlepage]{article} 
\usepackage{graphicx}
\usepackage[portuguese]{babel}
%\usepackage[applemac]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fullpage}

\usepackage{indentfirst} % primeiro parágrado indendado
\usepackage{listings}	 % para colocar código fonte
\usepackage{verbatimbox}
%\usepackage[pdftex,a4paper]{hyperref} % para criar links no pdf

\title{PCS2056 - Linguagens e Compiladores\\Compilador FM} 
\author{Felipe Giunte Yoshida N$^o$USP 4978231\\Mariana Ramos Franco N$^o$USP 5179364} 

\begin{document} 

\begin{figure}[!t]
\centering 
\includegraphics[width=15.5cm]{logo.pdf}
\end{figure}

\maketitle 
\tableofcontents
\newpage

% -- Introdução
\section{Introdução}

Este projeto foi desenvolvido para a disciplina PCS2056 - Linguagens e Compiladores. Seu objetivo é a construção de um compilador que transforma uma linguagem imperativa chamada FM, que será definida a seguir, em código MVN. O programa foi desenvolvido em Java e consiste em quatro etapas cujas dependências podem ser observadas na figura \ref{intro}.

\begin{figure}[!ht]
\centering 
\includegraphics[width=15.5cm]{intro.pdf}
\caption{Etapas do projeto do compilador \label{intro}}
\end{figure}

\paragraph{Definição da linguagem} Baseada na linguagem C, a linguagem FM é basicamente a tradução da linguagem C do inglês ao português com algumas simplificações. 

\paragraph{Analisador léxico} A partir da linguagem, o analisador léxico permite a divisão do código de entrada do compilador em diversos tokens, formando um Fluxo de tokens. Além disso, ele inicia uma tabela com dados sobre as variáveis do programa, chamada de tabela de símbolos.

\paragraph{Analisador sintático} A etapa do analisador sintático pode ser dividida em duas partes. Na primeira, temos a montagem no autômato de pilha estruturado a partir da definição da linguagem. Na segunda, este autômato recebe o fluxo de tokens e a tabela de símbolos, checando se o código é reconhecido pela linguagem.

\paragraph{Analisador semântico} O analisador semântico age juntamente do reconhecimento do código feito pelo analisador sintático. Com o reconhecimento dos tokens, instruções MVN são geradas no arquivo de saída.

% -- Definição da Linguagem
\section{Definição da Linguagem}

A linguagem adotada no projeto corresponde à uma simplificação da linguagem de programação C, onde os comandos em inglês (IF, ELSE, WHILE, ...) foram traduzidos para o português (SE, SENAO, ENQUANTO, ...).

Além disso, os seguintes recursos foram retirados da linguagem:

\begin{itemize}
\item comandos: for, do while, switch/case
\item ponteiros
\item tipos: short/long, signed/unsigned, float/double
\item alguns operadores unários
\item alguns operadores binários
\item union, enum
\item include, typedef
\item etc...
\end{itemize}

Desta maneira, a linguagem adotada (que chamaremos de linguagem FM) aceita programas formados por uma seqüência de comandos. Os comando aceitos pela linguagem são os seguintes:

\begin{itemize}
\item Registro
\item Declaração de variáveis
\item Atribuição de valor à uma variável
\item Comando iterativo: enquanto
\item Comando condicional: se/senao
\item Chamada de função
\item Comando de entrada de dados
\item Comando de saída de dados
\end{itemize}

Abaixo encontra-se a descrição formal da linguagem através da notação BNF e da notação de Wirth.

% -- Definição Formal da Linguagem -- Notação BNF
\subsection{Definição Formal da Linguagem -- Notação BNF}

\lstset{
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
%frame=single,	                % adds a frame around the code
tabsize=4,	                	% sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
basicstyle=\ttfamily\footnotesize,     	% Estilo geral (fonte pequena, monoespaçada "true type")
breaklines=true                 % sets automatic line breaking
}

\lstinputlisting[label=BNF]{NotacaoBNF.txt}	

\paragraph{}	% linha em branco

% -- Definição Formal da Linguagem -- Notação de Wirth
\subsection{Definição Formal da Linguagem -- Notação de Wirth}

\lstinputlisting[label=Wirth]{NotacaoWirth.txt}

\paragraph{}	% linha em branco

% -- Simplificação da Gramática
\subsection{Simplificação da Gramática} \label{sub:simplificacao}

Para permitir a implementação do autômato de pilha estruturado, método que será utilizado para a construção do analisador sintático, a descrição em notação de Wirth mostrada anteriormente foi reduzida, agrupando os não-terminais essenciais à linguagem.

\lstinputlisting[label=Wirth]{NotacaoSimplificada.txt}

\paragraph{}	% linha em branco

\section{Descrição do analisador léxico} \label{sec:lexico}

A função desta etapa do compilador é receber o código fonte como entrada, dividi-lo em tokens e preencher parte da tabela de símbolos. Para esta funcionalidade, implementamos o autômato finito representado na figura \ref{AFD}, que recebe cada caractere do código fonte e cada vez que volta ao estado inicial, pode escrever um token na estrutura de fluxo de tokens e pode também colocar uma entrada na tabela de símbolos.

\begin{figure}[!h]
\centering 
\includegraphics[width=15.5cm]{AFD.pdf}
\caption{Autômato finito equivalente à gramática definida \label{AFD}}
\end{figure}


\begin{minipage}[t]{0.5\linewidth} % A minipage that covers half the page
	\textbf{Estados:}\\
	1 - Inicial\\
	2 - Número\\
	3 - Seqüência de caracteres\\
	4 - Caracter especial\\
	5 - Divisão\\
	6 - Comentário\\
	7 - Comparação ou atribuição\\
	8 - Comparação\\		
\end{minipage}
\begin{minipage}[t]{0.5\linewidth}
	\textbf{Entradas:}\\
	A - Qualquer caracter\\
	B - Nova linha\\
	C - Caracteres especiais (. , ; + - * ( ) [ ] \{ \})\\
	E - Igual\\ (=)
	G - Maior ou menor (< >)\\
	L - Letra [A-z]\\
	N - Número [0-9]\\
	S - Barra (/)\\
\end{minipage}

Dividimos a implementação do analisador léxico em duas etapas: a primeira monta o autômato em uma estrutura interna de acordo com um arquivo XML e o segundo simula tal autômato a partir do código fonte.

\subsection{Montagem do autômato finito}

\subsubsection{XML}

Nesta etapa, o programa lê um arquivo XML como indicado na figura \ref{xml}. Nele temos uma tag \emph{gramatica} que engloba todo o arquivo. Dentro desta tag, há um ou mais estados identificados com a tag \emph{estado}. Dentro dos estados há as tags \emph{id}, que é um número para identificar o estado, a tag \emph{final}, para informar se o estado pode finalizar um token, a tag \emph{tipo} para classificar o token de acordo com a o id mostrado na tabela \ref{tipo} quando o fim do mesmo é identificado  e zero ou mais transições, identificadas pelas tags \emph{transicao}. Cada transição tem um ou mais caracteres que indicam quais entradas que ativam a transição, identificados pela tag \emph{entradas} e o respectivo estado que é ativado.

\begin{verbbox}
<gramatica>
     <estado>
          <id>0</id>
          <final>false</final>
          <tipo>0</tipo>
          <transicao>
               <entradas>0123456789</entradas>
               <proximo>1</proximo>
          </transicao>
          [Outras transições]
     </estado>
     [Outros estados]
</gramatica>
\end{verbbox}
\begin{center}
\begin{figure}[!h]
\centering 
\theverbbox[t]\\
\caption{Estrutura do autômato descrito em XML \label{xml}}
\end{figure}
\end{center}


\begin{table}[!h]
\centering 
\begin{tabular}{|c|c|}
\hline
Tag \emph{tipo} & Significado\\ 
\hline
0 & Estado Inicial \\ 
1 & Número \\ 
2 & Seqüência de caracteres \\ 
3 & Caractere especial \\ 
4 & Comentário \\ 
5 & String\\
6 & Reservado\\
\hline 
\end{tabular}
\caption{Relação entre a identificação da tag \emph{tipo} do XML e o tipo do estado \label{tipo}}
\end {table}

No exemplo da figura \ref{xml}, é mostrado apenas um estado, inicial, que não finaliza tokens. Ao receber um número, há uma transição para o estado 1, que não é mostrado.

\subsubsection{Estrutura do autômato} \label{subsub:estrutura}

Podemos ver na figura \ref{classes_afd} o diagrama de classes da estrutura em qual o autômato do arquivo XML é transformado. Temos basicamente três classes: AFD (autômatos), Estado e Transição. Iremos descrever a partir de agora cada uma destas classes, seus métodos e atributos. Como os \emph{gets} e \emph{sets} não necessitam de explicação, serão ignorados.

\begin{figure}[!h]
\centering 
\includegraphics[height=15cm]{classes_AFD.pdf}
\caption{Diarama de classes do autômato \label{classes_afd}}
\end{figure}

\paragraph{AFD}

\subparagraph{Atributos} Um autômato, como esperado, tem uma série de estados, armazenados no vetor \emph{estados}. A variável \emph{estadoAtivo} indica qual deles está ativo naquele momento e \emph{nome} armazena o nome do autômato.

\subparagraph{Métodos} 

Os dois métodos \emph{adicionaEstado} obviamente adicionam um estado na máquina. A diferença é que um define o estado como ativo se ele é considerado inicial, e o outro, caso a entrada \emph{inicial} seja verdadeira. \emph{estadoAtivoFinal} verifica se o estado atual é final ou não. \emph{removeEstado} remove um estado do autômato. O método \emph{procuraEstado} retorna o id do vetor estados equivalente ao estado com o id definido dentro da classe Estado.  Já o método \emph{temTransicao}, retorna um booleano que indica se há uma transição válida  do estado ativo para a o caractere de entrada.  O método \emph{percorre} é um dos mais importantes. Ele é usado na simulação do autômato, onde o caractere de entrada faz a transição para o próximo estado automaticamente e altera todas as variáveis internas do autômato.  Finalmente, o método \emph{transicaoFinal} indica se o estado ativo emite um token ou não. Os métodos \emph{temTransicao} e \emph{pecorre} têm duas versões, pois os autômatos são usados tanto nesta etapa de tokens, de caractere em caractere, ou mais à frente, com strings.

\paragraph{Estado}

\subparagraph{Atributos} Cada estado é identificado por seu \emph{id}. Há também a indicação se ele emite um token ou não, pela variável \emph{aceitacao}. A variável \emph{tipo} foi descrita anteriormente na tabela \ref{tipo}, e indica qual o tipo de token a partir deste estado. \emph{numTransicoes} guarda o número de transições que saem deste estado e \emph{transicoes} é um vetor de transições.

\subparagraph{Métodos} Há basicamente quatro métodos relevantes nesta classe. O primeiro, \emph{adicionaTransicao}, adiciona uma transição ao estado. Já o método \emph{proximoEstado} retorna o id do próximo estado quando o caractere de entrada é recebido. \emph{naoDeterminismo} verifica se o estado tem apenas uma transição para cada entrada ou mais. Finalmente, \emph{removeTransicao} elimina uma transicao do estado.

\paragraph{Transicao}

\subparagraph{Atributos} Uma transição é composta pelo id do estado que ficará ativo (\emph{proximo}) quando alguma dos caracteres do vetor \emph{entrada} é recebido.

\subparagraph{Métodos} O método \emph{proximoEstado} retorna o id do estado que é ativado com o caractere de entrada ou -1 caso não haja transição válida.

\subsection{Simulação do autômato finito}

Para a simulação do autômato, tomamos como o mesmo já definido na estrutura descrita no item anterior. Como vimos, o método \emph{percorre} é o que realiza esta função com a ajuda dos outros métodos já descritos. Portanto, focaremos nesta etapa a descrição das estruturas que recebem os dados vindos da máquina.

\subsubsection{Estrutura do fluxo de tokens}

\begin{figure}[!h]
\centering 
\includegraphics[width=15.5cm]{classes_fluxo.pdf}
\caption{Diarama de classes do fluxo de tokens \label{classes_fluxo}}
\end{figure}

\paragraph{FluxoTokens} 

\subparagraph{Atributos} Um vetor de tokens é armazenado na variável \emph{tokens}, onde seu tamanho é armazenado na variável \emph{tamanho}.

\subparagraph{Métodos} O método \emph{adicionaToken} adiciona um token no vetor de tokens, e o método recuperaToken, devolve o próximo token da lista e o elimina.

\paragraph{Token}  

\subparagraph{Atributos} A variável \emph{valor} guarda o nome das variáveis representadas pelos tokens. A variável \emph{tipo} estabelece uma relação numérica com a tabela de símbolos e a variável. \emph{linha} e \emph{coluna} armazenam a posição do tokenno código.

\subparagraph{Métodos} Não há métodos a serem descritos.

\subsubsection{Estrutura da tabela de símbolos}

\begin{figure}[!h]
\centering 
\includegraphics[width=15.5cm]{classes_simbolos.pdf}
\caption{Diarama de classes da tabela de símbolos \label{classes_simbolos}}
\end{figure}

\paragraph{TabelaDeSimbolos}

\subparagraph{Atributos} Apenas o primeiro simbolo da tabela é armazenado na variável \emph{simbolo}, onde seu tamanho é armazenado na variável \emph{entradas}. Posteriormente, na parte da análise sintática as variáveis \emph{escopo} identificrão o escopo ao qual a tabela pertence e \emph{escopoAnterior}  a tabela vinculada ao escopo anterior da atual.

\subparagraph{Métodos} O método \emph{adicionaEntrada} adiciona um símbolo na tabela de símbolos. \emph{estaNaTabela} verifica se um dado símbolo está na tabela. As diversas instâncias de \emph{recuperaEntrada} recuperam um símbolo da tabela com diferentes valores de procura.

\paragraph{Simbolo}

\subparagraph{Atributos} \emph{Id} é a ligação numérica de um símbolo com o fluxo de tokens. \emph{Nome} é um identificador para o símbolo, \emph{tipo} é uma classificação do mesmo tipo da tabela \ref{tipo}. \emph{Linha} e \emph{coluna} indicam onde cada token está dentro do código fonte, e próximo é o próximo token da tabela. \emph{proximo} é o próximo símbolo da tabela, cujo tamanho é indicado por \emph{tamanho}. \emph{inicializado} e \emph{endereco} serão usados mais adiante. O primeiro indica se a váriavel já foi alocada no código, e a segunda indica seu endereço.

\subparagraph{Métodos} \emph{isInicializado} retorna se a variável já alocada ou não, e \emph{jaDeclarado} indica se ela já está na tabela.

\subsection{Classes especiais}

Definimos também algumas classes especiais, responsáveis por guardar dados e facilitar uma rápida modificação em dados caso necessário. Temos duas classes, \emph{TiposLexico} e \emph{PalvrasReservadas}. A primeira apenas guarda os dados da tabela \ref{tipo}. Já a segunda, explicitada na figura \ref{classe_palavras}, contém as palavras da figura \ref{palavras}. Internamente, o vetor \emph{palavras} contém estas palavras e o método \emph{resevada} indica se a seqüência de caracteres de entrada está nessa lista.

\begin{figure}[!hbt]
	\begin{minipage}[b]{0.5\linewidth} % A minipage that covers half the page
\centering 
\includegraphics[height=1.5cm]{classes_palavras.pdf}
\caption{Diarama de classes da lista de palavras \label{classe_palavras}}
	\end{minipage}
	\hspace{0.7cm} % To get a little bit of space between the figures
	\begin{minipage}[b]{0.5\linewidth}
\centering 
\begin{tabular}{|c|}
\hline
Palavras\\ 
\hline
estrut\\ 
principal\\ 
retorno\\ 
inteiro\\ 
caracteres\\
booleano\\
entrada\\ 
saida\\
se\\
senao\\
enquanto\\
verdadeiro\\
falso\\
\hline 
\end{tabular}
\caption{Palavras reservadas \label{palavras}}
	\end{minipage}
\end{figure}

\subsection{Teste}

Para testar esta etapa do compilador, criamos um pequeno código que é capaz de testar todas as funcionalidades da mesma. Ele é apresentado na figura \ref{teste}. Nele testamos todos os tipos identificáveis do analisador léxico: seqüência de caracteres, números, caracteres especiais, comparadores, atribuidores, comentários, atribuidores aritméticos e um caractere inválido. O resultado, obtido a partir do log desta etapa, pode ser visto logo abaixo.

\begin{verbbox}
principal () {

	inteiro var1;
	inteiro var2;
	
	var1 = 0;
	var2 = 3;
	
	funcao();
	
	enquanto (var1 < (var2+1) ){
		var1 = var1 + 1;
	}
	
	var1 = (var1 * 5) / var1 + 3;
	saida = var1;
}
\end{verbbox}
\begin{center}
\begin{figure}[!h]
\centering 
\theverbbox[t]\\
\caption{Código de teste \label{teste}}
\end{figure}
\end{center}

\subsubsection{Resultado}

\lstinputlisting[label=resultado]{TesteLexico.txt}


\paragraph{}  % linha em branco


%*******************************************
% Descrição do analisador sintático
%*******************************************
\section{Projeto do analisador sintático}

O analisador sintático consiste de um autômato de pilha estruturado criado automaticamente por um meta-analisador a partir da descrição simplificada da gramática na notação de Wirth apresentada no item \ref{sub:simplificacao}.


% META-ANALISADOR
\subsection{Meta-analisador}

Para facilitar o processo de obtenção do autômato de pilha estruturado e de suas submáquinas, referentes aos não-terminais de nossa linguagem, foi criado um meta-analisador que, a partir da gramática na notação de Wirth, automatiza a geração do reconhecedor sintático. O desenvolvimento do meta-analisador seguiu o método apresentado em \cite{metacompilador} .

Assim, no desenvolvimento do meta-analisador, procuramos utilizar o mesmo esquema criado para gerar o autômato na parte léxica do projeto, ou seja, primeiro descrever o autômato em XML e depois monta-lo na estrutura utilizada para sua representação dentro do compilador.

Algumas modificações foram feitas no XML de entrada e na estrutura utilizada para representar o autômato.

% MONTAGEM DO META-ANALISADOR
\subsection{Montagem do meta-analisador} \label{sub:monta_meta}

% XML
\subsubsection{XML}

Para conseguir representar o autômato de pilha estruturado representativo da gramática de Wirth, constituído das submáquinas WIRTH e EXPR, utilizamos a estrutura XML apresentada à seguir:

\lstset{language=XML}
\begin{lstlisting}
<gramatica>
	 <nterminal>
	 	<nome>WIRTH</nome>
	    <estado>
          <id>0</id>
          <final>false</final>
          <transicao>
              <entradas>NTERM</entradas>
              <proximo>2</proximo>
          </transicao>
          [Outras transições]
     	</estado>
     	[Outros estados]
     </nterminal>
     [Outros não-terminais]
</gramatica>
\end{lstlisting}


Assim, através dessa estrutura, definimos no arquivo \textbf{metacompilador.xml} as duas submáquinas WIRTH e EXPR, responsável pelo reconhecimento das gramáticas em notação de Wirth.


\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.50]{fig_wirth.png}
		\caption{Submáquina WIRTH}
		\label{fig:wirth}
	\end{center}
\end{figure}


\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.60]{fig_expr.png}
		\caption{Submáquina EXPR}
		\label{fig:expr}
	\end{center}
\end{figure}


% Estrutura do autômato
\subsubsection{Estrutura do autômato}

Além das estruturas já apresentadas no item \ref{subsub:estrutura}, criamos uma classe \textbf{APE} (Autômato de Pilha Estruturado), que armazena a lista de submáquinas descritas pela classe \textbf{AFD} (Autômato Finito Determinístico).

Assim, a clase \textbf{MontaMetaAPE}, a partir do XML mostrado no item anterior, cria para cada não-terminal (WIRTH e EXPR) uma submáquina através da classe \textbf{AFD}, e ao final, estas submáquinas são adicionadas à um objeto da classe \textbf{APE}. 



% Léxico
\subsubsection{Léxico} \label{subsub:meta_lexico}

Antes de simular o autômato de pilha estruturado da gramática de Wirth, é necessário tratar o arquivo de entrada \textbf{gramatica.txt}, que contêm a descrição da nossa linguagem.

Assim, usando o mesmo método utilizado no item \ref{sec:lexico}, trocamos o autômato responsável por identificar o tipo de cada token (TERM, NTERM, ESPECIAL), pelo apresentado na figura \ref{fig:meta_lexico} e descrito no arquivo \textbf{metalexico.xml}.

\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.70]{fig_lexico.png}
		\caption{Autômato finito usado na parte léxica do meta-analisador}
		\label{fig:meta_lexico}
	\end{center}
\end{figure}


% SIMULAÇÂO DO AUTÔMATO
\subsection{Funcionamento do meta-analisador}

A classe \textbf{MetaCompilador}, através do método \textbf{executa}, é responsável por efetuar as ações do meta-analisador.

Assim, primeiramente, é montado o meta-analisador através da classe \textbf{MontaMetaAPE}, como já apresentado no item \ref{sub:monta_meta}.

Depois disso, executa-se o léxico (item \ref{subsub:meta_lexico}) que lê o arquivo de entrada \textbf{gramatica.txt} para criar o fluxo de tokens.

Esse fluxo de tokens é então usado através da classe \textbf{PercorreMetaAPE} para criar o autômato de pilha estruturado da nossa linguagem. Para isso, a classe \textbf{PercorreMetaAPE} implementa as ações semânticas apresentadas em \cite{metacompilador}.

Em seguida, o objeto da classe \textbf{APE} obtido é minimizado, retirando as transições em vazio e eliminando não determinismos através do seu método \textbf{minimiza}. 

Obtemos, assim, o autômato de pilha estruturado da linguagem FM.

\subsection{Reconhecedor de pilha determinístico}

Uma vez construído o reconhecedor, inicia-se o reconhecimento do código de entrada. Novamente é usado a estrutura APE, que desta vez contém três submáquinas que podem ser vistas nas figuras \ref{programa}, \ref{comando} e \ref{expressao}. Uma vez que as submáquinas já não têm não-determinismos e transições vazias, o processo de reconhecimento é direto.

Para cada token recebido da análise léxica, um \emph{lookahead} é feito para se determinar se há uma transição válida na submáquina ou em alguma outra submáquina que possa ser derivada desta. A cada passo no reconhecimento, dados são passados para a análise semântica, que será descrita a seguir, e que é responsável pela geração de código.

\section{Descrição do analisador semântico}

Como visto na seção anterior, tokens são passados desde a a etapa do reconhecedor para a análise semântica, a fim de se gerar código. Nesta etapa, uma série de pilhas são usadas para manter registro do estado atual da geração de código.

Dentre as estruturas mais importantes usadas nesta etapa, podemos citar:

\begin{itemize}
\item{Vetor de escopos: responsável por manter um índice dos diferentes escopos (blocos) do código}
\item{Tabela de símbolos: usada novamente para manter registro das variáveis e sua declaração}
\item{Pilha de tokens: mantém um registro dos últimos tokens recebidos, a fim de se manter o contexto}
\item{Pilhas de declarações e instruções: guardam as instruções que serão usadas para gerar o código}
\item{Pilha de operadores e operandos: usado na submáquina de expressão}
\end{itemize}

\subsection{MVN}

O código objeto se dará na linguagem MVN. Podemos observar na figura \ref{mvn} o mnemônicos disponíveis para a linguagem.

\begin{figure}[!ht]
\centering 
\includegraphics[width=15.5cm]{mvn.pdf}
\caption{Mnemônicos da MVN \label{mvn}}
\end{figure}


\subsection{Submáquina programa}

A submáquina programa é responsável pela criação de código de registro, funções e do corpo principal do programa.

\begin{figure}[!ht]
\centering 
\includegraphics[height=22.5cm]{programa.pdf}
\caption{Autômato finito equivalente à submáquina programa \label{programa}}
\end{figure}

\subsection{Submáquina comando}

As funções definidas para a máquina comando são a atribuição de valores, a definição de variáveis, comparações, entrada e saída de dados e chamadas de funções.

\begin{figure}[!ht]
\centering 
\includegraphics[width=15.5cm]{comando.pdf}
\caption{Autômato finito equivalente à submáquina expressão \label{comando}}
\end{figure}

\subsection{Submáquina expressão}

A submáquina expressão funciona basicamente com duas pilhas, uma de operadores e uma de operandos.

\begin{figure}[!ht]
\centering 
\includegraphics[height =22.5cm]{expressao.pdf}
\caption{Autômato finito equivalente à submáquina comando \label{expressao}}
\end{figure}

\section{Conclusões}

\subsection{Limitações}

Infelizmente, devido à restrições de tempo, algumas funções não puderam ser implementadas na etapa final do projeto, a semântica. Elas estão listadas à seguir:

\begin{itemize}
\item{Registro}
\item{Vetores}
\item{Uso de parâmetros}
\item{Expressões booleanas}
\item{\emph{Strings}}
\item{Caracteres}
\end{itemize}

Em todos os casos, o código chega a ser aceito, já que o reconhecedor está funcional. Porém, nehum código é gerado.

\subsection{Testes}

Para se testar todas as funções implementadas, realizamos um teste final com o seguinte código:

\begin{verbatim}
// exemplo de funcao
inteiro funcao(){
	inteiro param;
	inteiro var1;
	
	param = 0;
	var1 = 15;
	
	saida = var1;
	
	enquanto ( param <= 2) {
		param = param + 1;
		saida = param;
	}
	retorno param;
}

// rotina de inicio do programa
principal () {

	// declaracao de variavel para tipo int e boolean
	inteiro var1;
	inteiro var2;
	booleano bol;
	
	// atribuicao de valor com verificacao de tipo
	bol = verdadeiro;	
	var1 = 0;
	var2 = 3;
	
	// nao eh possivel atribuir o valor de retorno da funcao para uma variavel
	funcao();
	
	// ifs e whiles aninhados e operacoes de comparacao com o valor de expressoes
	enquanto ( var1 < ( var2 * 2) ){
		var1 = var1 + 1;
		
		// if sem else
		se ( (var1 - 2) > 0 ){
			saida = var1;
		}
	}
	
	// if com else
	se (var1 == var2){
		saida = var1 + var2;
	
	}senao{
		var1 = var2;
		saida = var1;
	}
	
	// expressoes fazem verificacao de tipo
	var1 = (var1 * 5) / var1 + 3;
	
	// operacao de saida
	saida = var1;
}
\end{verbatim}

O código de saída pode ser observado abaixo.

\begin{verbatim}
@	/0
		JP	INICIO
NUM_0		K	/0	; 0
NUM_5		K	/5	; 5
NUM_2		K	/2	; 2
NUM_1		K	/1	; 1
VAR_0		K	/00	; param
VAR_1		K	/00	; var1
NUM_3		K	/3	; 3
VAR_2		K	/00	; var1
VAR_3		K	/00	; var2
FUNC_0		JP	/00
		LD	NUM_0	; VAR_0 = NUM_0
		MM	VAR_0
		LD	NUM_5	; VAR_1 = NUM_5
		MM	VAR_1
		LD	VAR_1	; TEMP_0 = VAR_1
		MM	TEMP_0
		LD	TEMP_0
		MM	ARG_INT
		SC	PRINT_INT
		LD	RESULT_ASC
		PD	/100	; SAIDA = TEMP_0
		LD	NEW_LINE
		PD	/100
LOOP_0		LD	/00
		LD	VAR_0	; TEMP_0 = VAR_0
		MM	TEMP_0
		LD	NUM_2	; TEMP_1 = NUM_2
		MM	TEMP_1
		LD	TEMP_1	; WHILE ( TEMP_0 <= TEMP_1 )
		-	TEMP_0
		JN	ENDLOOP_0
		LD	VAR_0	; TEMP_0 = VAR_0 + NUM_1
		+	NUM_1
		MM	TEMP_0
		LD	TEMP_0	; VAR_0 = TEMP_0
		MM	VAR_0
		JP	LOOP_0
ENDLOOP_0		LD	/00	; END WHILE
		LD	VAR_0	; TEMP_0 = VAR_0
		MM	TEMP_0
		LD	TEMP_0
		MM	ARG_INT
		SC	PRINT_INT
		LD	RESULT_ASC
		PD	/100	; SAIDA = TEMP_0
		LD	NEW_LINE
		PD	/100
		LD	VAR_0	; RETURN VAR_0
		RS	FUNC_0
INICIO		LD	/00
		LD	NUM_0	; VAR_2 = NUM_0
		MM	VAR_2
		LD	NUM_3	; VAR_3 = NUM_3
		MM	VAR_3
		SC	FUNC_0
LOOP_1		LD	/00
		LD	VAR_2	; TEMP_0 = VAR_2
		MM	TEMP_0
		LD	VAR_3	; TEMP_2 = VAR_3 + NUM_1
		+	NUM_1
		MM	TEMP_2
		LD	TEMP_2	; TEMP_1 = TEMP_2
		MM	TEMP_1
		LD	TEMP_1	; WHILE ( TEMP_0 < TEMP_1 )
		-	TEMP_0
		JN	ENDLOOP_1
		JZ	ENDLOOP_1
		LD	VAR_2	; TEMP_0 = VAR_2 + NUM_1
		+	NUM_1
		MM	TEMP_0
		LD	TEMP_0	; VAR_2 = TEMP_0
		MM	VAR_2
		JP	LOOP_1
ENDLOOP_1		LD	/00	; END WHILE
IF_0		LD	/00
		LD	VAR_2	; TEMP_0 = VAR_2
		MM	TEMP_0
		LD	VAR_3	; TEMP_1 = VAR_3
		MM	TEMP_1
		LD	TEMP_0	; IF ( TEMP_0 == TEMP_1 )
		-	TEMP_1
		JZ	IF_EQ_0
		JP	ELSE_0
IF_EQ_0		LD	/00
		LD	VAR_2	; TEMP_1 = VAR_2 + VAR_3
		+	VAR_3
		MM	TEMP_1
		LD	TEMP_1	; TEMP_0 = TEMP_1
		MM	TEMP_0
		LD	TEMP_0
		MM	ARG_INT
		SC	PRINT_INT
		LD	RESULT_ASC
		PD	/100	; SAIDA = TEMP_0
		LD	NEW_LINE
		PD	/100
		JP	ENDIF_0
ELSE_0		LD	/00	; ELSE
		LD	VAR_3	; VAR_2 = VAR_3
		MM	VAR_2
		LD	VAR_2	; TEMP_0 = VAR_2
		MM	TEMP_0
		LD	TEMP_0
		MM	ARG_INT
		SC	PRINT_INT
		LD	RESULT_ASC
		PD	/100	; SAIDA = TEMP_0
		LD	NEW_LINE
		PD	/100
ENDIF_0		LD	/00	; END IF
		LD	VAR_2	; TEMP_0 = VAR_2 * NUM_5
		*	NUM_5
		MM	TEMP_0
		LD	TEMP_0	; TEMP_1 = TEMP_0 / VAR_2
		/	VAR_2
		MM	TEMP_1
		LD	TEMP_1	; TEMP_2 = TEMP_1 + NUM_3
		+	NUM_3
		MM	TEMP_2
		LD	TEMP_2	; VAR_2 = TEMP_2
		MM	VAR_2
		LD	VAR_2	; TEMP_0 = VAR_2
		MM	TEMP_0
		LD	TEMP_0
		MM	ARG_INT
		SC	PRINT_INT
		LD	RESULT_ASC
		PD	/100	; SAIDA = TEMP_0
		LD	NEW_LINE
		PD	/100
FIM		HM	/00
TEMP_0		K	/00
TEMP_1		K	/00
TEMP_2		K	/00
TEMP_3		K	/00
TEMP_4		K	/00
TEMP_5		K	/00
TEMP_6		K	/00
TEMP_7		K	/00
TEMP_8		K	/00
TEMP_9		K	/00
TEMP_10		K	/00
TEMP_11		K	/00
TEMP_12		K	/00
TEMP_13		K	/00
TEMP_14		K	/00
TEMP_15		K	/00
TEMP_16		K	/00
TEMP_17		K	/00
TEMP_18		K	/00
TEMP_19		K	/00
TEMP_20		K	/00
PRINT_INT		JP	/00
		LD	ARG_INT	; CONVERT INT TO ASC
		+	OFFSET
		MM	RESULT_ASC
		LD	STRING_1
		PD	/100	;
		LD	STRING_2
		PD	/100	;
		LD	STRING_3
		PD	/100	;
		LD	STRING_4
		PD	/100	;
		LD	STRING_5
		PD	/100	;
		LD	STRING_6
		PD	/100	;
		LD	STRING_7
		PD	/100	;
		LD	STRING_6
		PD	/100	;
		RS	PRINT_INT
ARG_INT		K	/00	; ARG INT
RESULT_ASC		K	/00	; RESULT ASC
OFFSET		K	/30	; OFFSET
STRING_1		K	/53	; S
STRING_2		K	/41	; A
STRING_3		K	/49	; I
STRING_4		K	/44	; D
STRING_5		K	/41	; A
STRING_6		K	/20	; 
STRING_7		K	/3d	; =
NEW_LINE		K	/0a	; NEW LINE
\end{verbatim}

\begin{thebibliography}{10} 

\bibitem{jj} Neto, J. J.:
\emph{Introdução à compilação}, 
1$^{a}$ edição, LTC, 1987

\bibitem{dragao} Aho, A. V.; Lam, M. S.; Sethi, R.; Ullman J. D.:
\emph{Compiladores: Princípios, técnicas e ferramentas}, 
2$^{a}$ edição, Pearson, 2008

\bibitem{metacompilador} Neto, J. J., Parientem C. B., Leonardi F.: \emph{Compiler Construction: A Pedagogical Approach}. Proceedings of the
ICIE. Buenos Aires. 1999. [disponível para download em www.pcs.usp.br/~lta]
\end{thebibliography}

\end{document} 